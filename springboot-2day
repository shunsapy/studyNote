1.跨域cros
springboot实现WebMvcConfigurer,并实现addCorsMappings方法，添加允许跨域的请求路径、请求头、请求方法、试探有效期时间、可跨的域名等等

@Configuration
public class MyWebMvcConfig implements WebMvcConfigurer {
	@Override
	public void addCorsMappings(CorsRegistry registry) {
		// TODO Auto-generated method stub
		registry.addMapping("/book/**")
				.allowedHeaders("*")
				.allowedMethods("*")
				.maxAge(1800)
				.allowedOrigins("http://localhost:8081");
	}
}

配置完成后，可实现前后端分离、微服务等跨域请求。

2.注册拦截器
创建一个拦截器类，让其实现拦截器接口HandlerInterceptor：
public class LoginInterceptorl implements HandlerInterceptor{
	
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		// TODO Auto-generated method stub
		System.out.println("login-preHandle");
		return HandlerInterceptor.super.preHandle(request, response, handler);
	}
	
	@Override
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			ModelAndView modelAndView) throws Exception {
		// TODO Auto-generated method stub
		System.out.println("login-postHandle");

		HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
	}
	
	@Override
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
			throws Exception {
		// TODO Auto-generated method stub
		System.out.println("login-afterCompletion");

		HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
	}

}

所有拦截器链路上都先执行preHandle方法，然后执行请求方法，再执行postHandler,最后执行afterCompletion方法
注意：拦截器链路上只要有一个preHandle返回的是false，则之后的所有方法都不会执行，包括拦截器链路

注册到拦截器链路上ddInterceptor，并指定拦截的路径规则addPathPatterns：
@Configuration
public class MyWebMvcConfig implements WebMvcConfigurer {

	
	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		// TODO Auto-generated method stub
		registry.addInterceptor(new LoginInterceptorl()).addPathPatterns("/**").excludePathPatterns("/hello");
		...
		...
	}
}
